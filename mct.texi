\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename mct.info
@settitle Minibuffer and Completions in Tandem (mct.el)
@documentencoding UTF-8
@documentlanguage en
@set MAINTAINERSITE @uref{https://protesilaos.com,maintainer webpage}
@set MAINTAINER Protesilaos Stavrou
@set MAINTAINEREMAIL @email{info@protesilaos.com}
@set MAINTAINERCONTACT @uref{mailto:info@protesilaos.com,contact the maintainer}
@c %**end of header

@copying
Copyright (C) 2021  Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being “A GNU Manual,” and
with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled “GNU Free Documentation License.”

(a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
modify this GNU manual.”

@end quotation
@end copying

@dircategory Emacs misc features
@direntry
* Minibuffer and Completions in Tandem: (mct). Enhancement of the default minibuffer completion.
@end direntry

@finalout
@titlepage
@title Minibuffer and Completions in Tandem (mct.el)
@author Protesilaos Stavrou (@email{info@@protesilaos.com})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top Minibuffer and Completions in Tandem (mct.el)

@insertcopying

This manual, written by Protesilaos Stavrou, describes the customization
options for @samp{mct.el}, and provides every other piece of information
pertinent to it.

The documentation furnished herein corresponds to stable version
0.1.0, released on 2021-10-22.  Any reference to a newer
feature which does not yet form part of the latest tagged commit, is
explicitly marked as such.

Current development target is 0.2.0-dev.

@end ifnottex

@menu
* Overview of mct.el: Overview of mctel. 
* Basic usage::
* Installation::
* Sample setup::
* Keymaps::
* Extensions::
* Alternatives::
* GNU Free Documentation License::
* Indices::

@detailmenu
--- The Detailed Node Listing ---

Basic usage

* Cyclic behaviour::
* Selecting candidates::

Indices

* Function index::
* Variable index::
* Concept index::

@end detailmenu
@end menu

@node Overview of mctel
@chapter Overview of mct.el

@cindex Overview of features
@findex mct-choose-completion-number
@vindex mct-minimum-input
@vindex mct-live-update-delay
@vindex mct-completion-blocklist
@vindex mct-completion-passlist
@vindex mct-hide-completion-mode-line
@vindex mct-remove-shadowed-file-name
@vindex mct-apply-completion-stripes
@vindex mct-stripe

Minibuffer and Completions in Tandem, also known as ``MCT'', ``Mct'', @samp{mct},
or @samp{mct.el}, is a package that enhances the default minibuffer and
@samp{*Completions*} buffer of Emacs 28 (or higher) so that they work together
as part of a unified framework.  The idea is to make the presentation
and overall functionality be consistent with other popular, vertically
aligned completion UIs while leveraging built-in functionality.

The main feature set that unifies the minibuffer and the @samp{*Completions*}
buffer consists of commands that cycle between the two, making it seem
like they are part of a contiguous space (@ref{Basic usage}).

MCT tries to find a middle ground between the frugal defaults and the
more opinionated completion UIs.  This is most evident in its approach
on how to present completion candidates.  Instead of showing them
outright or only displaying them on demand, MCT implements a minimum
input threshold as well as a slight delay before it pops up the
@samp{*Completions*} buffer and starts updating it to respond to user input.

Customisation options control the input threshold (@code{mct-minimum-input})
and the delay between live updates (@code{mct-live-update-delay}).  Similarly,
a blocklist and a passlist for commands are on offer:

@itemize
@item
The blocklist (@code{mct-completion-blocklist}) disables the live-updating
functionality for the commands specified therein.

@item
The passlist (@code{mct-completion-passlist}) always shows the Completions'
buffer for the designated command without accounting for the minimum
input threshold.
@end itemize

Other customisations:

@itemize
@item
@code{mct-hide-completion-mode-line} to hide the mode line of the
@samp{*Completions*} buffer.  This removes the separation between it and the
minibuffer, further contributing to the idea of a unified space
between the two.

@item
@code{mct-remove-shadowed-file-name} to clear shadowed file names when
@code{file-name-shadow-mode} is enabled.  This means that in prompts that use
file paths (such as @code{find-file}) when you start in, say, @samp{~/Git/mct.el}
and type @samp{~/} the previous file path is removed and only the new one is
inserted.  Whereas the default is to keep the original file name
visible yet ``shadowed'' by a different colour.

@item
@code{mct-show-completion-line-numbers} to always display line numbers in the
Completions' buffer.  This can be helpful to get a sense of the length
of the completion candidates' list.  Though note that line numbers are
displayed ephemerally while using the @code{mct-choose-completion-number}
command, which is bound to @samp{M-g M-g} in either the minibuffer or the
@samp{*Completions*} buffer.

@item
@code{mct-apply-completion-stripes} applies alternative background colours in
the Completions' buffer.  This is only tested with the @samp{modus-themes}
and will only work nicely if the main background is pure black or
white---other themes would need to add support for the faces we define
or, at least, users must modify the @code{mct-stripe} face.
@end itemize

@node Basic usage
@chapter Basic usage

@menu
* Cyclic behaviour::
* Selecting candidates::
@end menu

@node Cyclic behaviour
@section Cyclic behaviour

@cindex Cyclic behaviour
@findex mct-switch-to-completions-top
@findex mct-switch-to-completions-bottom
@findex mct-previous-completion-or-mini
@findex mct-next-completion-or-mini
@findex mct-list-completions-toggle

When @code{mct-mode} is enabled, some new keymaps are activated which add
commands for cycling between the minibuffer and the completions.
Suppose the following standard layout:

@example
-----------------
|               |
|               |
|               |
|  Buffer       |
|               |
|               |
|               |
-----------------
-----------------
|               |
|  Completions  |
|               |
-----------------
-----------------
|  Minibuffer   |
-----------------
@end example

When inside the minibuffer, pressing @samp{C-n} (or down arrow) takes you to
the top of the completions, while @samp{C-p} (or up arrow) moves to the bottom.
The commands are @code{mct-switch-to-completions-top} for the former and
@code{mct-switch-to-completions-bottom} for the latter.  If the @samp{*Completions*}
are not shown, then the buffer pops up automatically and point moves to
the given position.

Similarly, while inside the @samp{*Completions*} buffer, @samp{C-p} (or up arrow) at
the top of the buffer switches to the minibuffer, while @samp{C-n} (or down
arrow) at the bottom of the buffer also goes to the minibuffer.  If
point is anywhere else inside the buffer, those key bindings perform a
regular line motion.  The commands are @code{mct-previous-completion-or-mini}
and @code{mct-next-completion-or-mini}.

The display of the @samp{*Completions*} can be toggled at any time from inside
the minibuffer with @samp{C-l} (mnemonic is ``[l]ist completions'' and the
command is @code{mct-list-completions-toggle}).

@node Selecting candidates
@section Selecting candidates

@cindex Candidate selection
@findex mct-edit-completion

There are several ways to select a completion candidate.

@enumerate
@item
Suppose that you are typing @samp{mod} with the intent to select the
@samp{modus-themes.el} buffer.  To complete the first candidate follow up
@samp{mod} with the @samp{TAB} key.  This is how you would do it with the default
minibuffer.  If done fast enough, no completions will be shown
(depending on your minimum input threshold and the live-update
delay).

@item
Upon cycling through the completions, type @samp{RET} to select the
candidate at point and exit the minibuffer.  This works for all types
of completion prompts.

@item
For certain contexts where selecting a candidate does not necessarily
mean that the process has to be finalised (e.g. when using @code{find-file})
selection in the @samp{*Completions*} buffer can be done with @samp{TAB} which
completes the item at point but does not exit the minibuffer.  The
command is instead renewed to update the list of completions with the
new candidates.

@item
Select a candidate by its line number by typing @samp{M-g M-g} in either the
minibuffer or the @samp{*Completions*} buffer.  This calls the command
@code{mct-choose-completion-number} which internally enables line numbers
and always makes the completions' buffer visible.

@item
In prompts that allow the selection of multiple candidates
(internally via the @code{completing-read-multiple} function) a @samp{[CRM]} label
is added to the text of the prompt.  The user thus knows that
pressing @samp{M-RET} in the @samp{*Completions*} will append the candidate at
point to the list of selections and keep the completions available so
that another item may be selected.  Any of the aforementioned
applicable methods can confirm the final selection.  If, say, you
want to pick a total of three candidates, do @samp{M-RET} for the first two
and @samp{RET} for the last one.  In contexts that are not CRM-powered, the
@samp{M-RET} has the same effect as @samp{RET}.

NOTE 2021-10-22: this assumes the @code{crm-separator} to be constant (the
comma @samp{,} character) but some commands @code{let} bind it to something else,
so the behaviour does not work as expected.  One such case is
@code{org-set-tags-command} which uses @samp{:} as a separator.

@item
Type @samp{M-e} (@code{mct-edit-completion}) in the completions' buffer to place
the current candidate in the minibuffer, without exiting the session.
This allows you to edit the text before confirming it.
@end enumerate

@node Installation
@chapter Installation

MCT is not in any package archive for the time being, though I plan to
submit it to GNU ELPA (as such, any non-trivial patches require
copyright assignment to the Free Software Foundation).  Users can rely
on @samp{straight.el}, @samp{quelpa}, or equivalent to fetch the source.  Below are
the essentials for those who prefer the manual method.

Assuming your Emacs files are found in @samp{~/.emacs.d/}, execute the
following commands in a shell prompt:

@example
cd ~/.emacs.d

# Create a directory for manually-installed packages
mkdir manual-packages

# Go to the new directory
cd manual-packages

# Clone this repo and name it "mct"
git clone https://gitlab.com/protesilaos/mct.el.git mct
@end example

Finally, in your @samp{init.el} (or equivalent) evaluate this:

@lisp
;; Make Elisp files in that directory available to the user.
(add-to-list 'load-path "~/.emacs.d/manual-packages/")
@end lisp

Everything is in place to set up the package.

@node Sample setup
@chapter Sample setup

@cindex Sample configuration

Minimal setup:

@lisp
(require 'mct)
(mct-mode 1)
@end lisp

And with more options:

@lisp
(require 'mct)

(setq mct-remove-shadowed-file-names t) ; works when `file-name-shadow-mode' is enabled
(setq mct-hide-completion-mode-line t)
(setq mct-show-completion-line-numbers nil)
(setq mct-apply-completion-stripes t)
(setq mct-minimum-input 3)
(setq mct-live-update-delay 0.6)

;; NOTE: `mct-completion-blocklist' can be used for commands with lots
;; of candidates, depending also on how low `mct-minimum-input' is.
;; With the settings shown here this is not required, otherwise I would
;; use something like this:
;;
;; (setq mct-completion-blocklist
;;       '( describe-symbol describe-function describe-variable
;;          execute-extended-command insert-char))
(setq mct-completion-blocklist nil)

;; This is for commands that should always pop up the completions'
;; buffer.  It circumvents the default method of waiting for some user
;; input (see `mct-minimum-input') before displaying and updating the
;; completions' buffer.
(setq mct-completion-passlist
      '(imenu
        Info-goto-node
        Info-index
        Info-menu
        vc-retrieve-tag))

(mct-mode 1)
@end lisp

Other useful extras from the Emacs source code:

@lisp
(setq enable-recursive-minibuffers t)
(setq minibuffer-eldef-shorten-default t)

(file-name-shadow-mode 1)
(minibuffer-depth-indicate-mode 1)
(minibuffer-electric-default-mode 1)
@end lisp

@node Keymaps
@chapter Keymaps

@cindex Keymaps
@vindex mct-completion-list-mode-map
@vindex mct-minibuffer-local-completion-map
@vindex mct-minibuffer-local-filename-completion-map

MCT defines its own keymaps, which extend those that are active in the
minibuffer and the @samp{*Completions*} buffer, respectively:

@itemize
@item
@code{mct-completion-list-mode-map}
@item
@code{mct-minibuffer-local-completion-map}
@item
@code{mct-minibuffer-local-filename-completion-map}
@end itemize

You can invoke @code{describe-keymap} to learn more about them.

If you want to edit any key bindings, do it in those keymaps, not in
those they extend and override (the names of the original ones are the
same as above, minus the @samp{mct-} prefix).

@node Extensions
@chapter Extensions

@cindex Extra packages

MCT only tweaks the default minibuffer.  To get more out of it, consider
these exceptionally well-crafted extras:

@table @asis
@item @samp{consult}
Adds several commands that make interacting with the
minibuffer more powerful.  There also are several packages that build
on it, such as @samp{consult-dir}.
@item @samp{embark}
Provides configurable contextual actions for completions and
many other constructs inside buffers.
@item @samp{marginalia}
Displays informative annotations for all known types of
completion candidates.
@item @samp{orderless}
A completion style that matches a variety of patterns
(regexp, flex, initialism, etc.) regardless of the order they appear
in.
@end table

@node Alternatives
@chapter Alternatives

@cindex Alternatives to MCT

The only alternative I have used that is conceptually close to MCT is
@samp{vertico}.  Vertico is a more mature and feature-rich package, while its
maintainer, Daniel Mendler, is an accomplished programmer.  Whereas MCT
is mostly an excuse to practice my Elisp skills.

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include doclicense.texi

@node Indices
@chapter Indices

@menu
* Function index::
* Variable index::
* Concept index::
@end menu

@node Function index
@section Function index

@printindex fn

@node Variable index
@section Variable index

@printindex vr

@node Concept index
@section Concept index

@printindex cp

@bye