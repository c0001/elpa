* Steps for the test.
** Test 1 
Using
the line 
#+begin_src
    ev = 0;                                                       %% el número de evaluaciones al inicio es cero, pues no ha habido ninguna iteración

#+end_src



    1) matlab-fill-comment-line   
    2) matlab-fill-paragraph
    3) matlab-fill-region
*** matlab-fill-comment-line
Result
#+begin_src
    ev = 0;                                                       %% el
                                                                  % número
                                                                  % de
                                                                  % evaluaciones
                                                                  % al
                                                                  % inicio
                                                                  % es
                                                                  % cero,
                                                                  % pues
                                                                  % no
                                                                  % ha
                                                                  % habido
                                                                  % ninguna
                                                                  % iteración

#+end_src

Changing the comment prefix from %% to % did not help
*** matlab-fill-paragraph
   same result
*** matlab-fill-region
   same result
** Test 2

Using
#+begin_src
        while diff > TOL && k <= nmax                             % por una parte se condiciona al while con un valor de tolerancia para el error diff, error de una iteración (de la iteración simple), y, por otra parte, se toma un numero máximo de iteraciones porque puede perfectamente el error de iteración no ser menor que la tolerancia, provocando un bucle infinito

#+end_src

But now setting fill-column to 100
***  matlab-fill-comment-line

Result
#+begin_src

        while diff > TOL && k <= nmax                             % por una parte se condiciona al
                                                                  % while con un valor de tolerancia
                                                                  % para el error diff, error de una
                                                                  % iteración (de la iteración
                                                                  % simple), y, por otra parte, se
                                                                  % toma un numero máximo de
                                                                  % iteraciones porque puede
                                                                  % perfectamente el error de
                                                                  % iteración no ser menor que la
                                                                  % tolerancia, provocando un bucle
                                                                  % infinito

#+end_src

Which looks nice. 
*** Whole buffer with matlab-fill-region

#+begin_src
Debugger entered--Lisp error: (error "Fill algorithm failed!")
  signal(error ("Fill algorithm failed!"))
  error("Fill algorithm failed!")
  matlab-fill-paragraph(nil)
  #f(compiled-function (&optional justify region) "Fill paragraph at or after point.\n\nIf JUSTIFY is non-nil (interactively, with prefix argument), justify as well.\nIf `sentence-end-double-space' is non-nil, then period followed by one\nspace does not end a sentence, so don't break a line there.\nThe variable `fill-column' controls the width for filling.\n\nIf `fill-paragraph-function' is non-nil, we call it (passing our\nargument to it), and if it returns non-nil, we simply return its value.\n\nIf `fill-paragraph-function' is nil, return the `fill-prefix' used for filling.\n\nThe REGION argument is non-nil if called interactively; in that\ncase, if Transient Mark mode is enabled and the mark is active,\ncall `fill-region' to fill each of the paragraphs in the active\nregion, instead of just filling the current paragraph." (interactive #f(compiled-function () #<bytecode -0x6dab22fd463fb72>)) #<bytecode -0x1241d3ac4eb2217>)(nil)
  apply(#f(compiled-function (&optional justify region) "Fill paragraph at or after point.\n\nIf JUSTIFY is non-nil (interactively, with prefix argument), justify as well.\nIf `sentence-end-double-space' is non-nil, then period followed by one\nspace does not end a sentence, so don't break a line there.\nThe variable `fill-column' controls the width for filling.\n\nIf `fill-paragraph-function' is non-nil, we call it (passing our\nargument to it), and if it returns non-nil, we simply return its value.\n\nIf `fill-paragraph-function' is nil, return the `fill-prefix' used for filling.\n\nThe REGION argument is non-nil if called interactively; in that\ncase, if Transient Mark mode is enabled and the mark is active,\ncall `fill-region' to fill each of the paragraphs in the active\nregion, instead of just filling the current paragraph." (interactive #f(compiled-function () #<bytecode -0x6dab22fd463fb72>)) #<bytecode -0x1241d3ac4eb2217>) nil)
  filladapt-funcall(fill-paragraph nil)
  filladapt-fill-paragraph(fill-paragraph nil)
  fill-paragraph(nil)
  matlab-fill-comment-line()
  funcall-interactively(matlab-fill-comment-line)
  call-interactively(matlab-fill-comment-line nil nil)
  command-execute(matlab-fill-comment-line)

#+end_src
*** Whole buffer with matlab-fill-region: commit 1b52a1d3359580f8c5d6bfbedb669b1420d8d0d5

    see the file, it did not change much and I receive:

    Paragraph Fill not supported in this context. [21 times]

*** Second file, running the command, returns error
Steps



    1) mark the whole buffer
    2) run matlab-fill-region.
       
#+begin_src
Debugger entered--Lisp error: (error "Fill algorithm failed!")
  signal(error ("Fill algorithm failed!"))
  error("Fill algorithm failed!")
  matlab-fill-paragraph(nil)
  matlab-fill-region(1 14464 nil)
  funcall-interactively(matlab-fill-region 1 14464 nil)
  call-interactively(matlab-fill-region nil nil)
  command-execute(matlab-fill-region)
#+end_src


*** file prob.m with commit b49c86e5738f23c9d8cebd5b4f1dd81a9ca4b27c

**** matlab-fill-code nil

Nothing is filled, not in 

    1) fill_prob.m
    2) nor in fill_prob2


**** matlab-fill-code t
In short it seems worse

Just using matlab-fill-comment-line on 

#+begin_src 
            k = k + 1;
            z = faux(t, yk, f, h, y);                              % hay que tener en cuenta que durante este bucle sólo se está considerando el tiempo t=tk +h con h valor de paso que corresponda, pero se mantiene fijo así como también se toma el valor inicial de y del paso anterior pero éste no está fijo 
#+end_src


Leads to 

#+begin_src 

function [teuler,yeuler,ev]=fill_prob(f,intv,y0,N,TOL,nmax) % Se implementa la función
                                                                   % correspondiente a la iteración
                                                                   % simple+dato inicial el valor
                                                                   % del paso anterior, yeuler = y0;
                                                                   % % Se toman los valores
                                                                   % iniciales que se dan como
                                                                   % argumento a = min(intv); b =
                                                                   % max(intv); h = (a + b)/N;
                                                                   % teuler = a; tk = a; yk = y0; ev
                                                                   % = 0; %el número de evaluaciones
                                                                   % al inicio es cero, pues no ha
                                                                   % habido ninguna iteración faux =
                                                                   % @(t, y, f, h, z) [y + h*f(t,
                                                                   % z)]; % se define la función
                                                                   % auxiliar para la iteración
                                                                   % simple for i = 1:N t = tk + h;
                                                                   % % se toma los valores del
                                                                   % tiempo correspondientes al paso
                                                                   % y = yk; diff = 100; % se toma
                                                                   % un numero arbitrariamente
                                                                   % grande para inicializar el
                                                                   % error de la iteración simple k
                                                                   % = 0; % se inicializa el conteo
                                                                   % para la iteración simple while
                                                                   % diff > TOL && k <= nmax % por
                                                                   % una parte se condiciona al
                                                                   % while con un valor de
                                                                   % tolerancia para el error diff,
                                                                   % error de una iteración (de la
                                                                   % iteración simple), y, por otra
                                                                   % parte, se toma un numero máximo
                                                                   % de iteraciones porque puede
                                                                   % perfectamente el error de
                                                                   % iteración no ser menor que la
                                                                   % tolerancia, provocando un bucle
                                                                   % infinito k = k + 1; z = faux(t,
                                                                   % yk, f, h, y); % hay que tener
                                                                   % en cuenta que durante este
                                                                   % bucle sólo se está considerando
                                                                   % el tiempo t=tk +h con h valor
                                                                   % de paso que corresponda, pero
                                                                   % se mantiene fijo así como
                                                                   % también se toma el valor
                                                                   % inicial de y del paso anterior
                                                                   % pero éste no está fijo

#+end_src

Which destroys the whole file. 

If however 

#+begin_src 

            k = k + 1;

            z = faux(t, yk, f, h, y);                              % hay que tener en cuenta que durante este bucle sólo se está considerando el tiempo t=tk +h con h valor de paso que corresponda, pero se mantiene fijo así como también se toma el valor inicial de y del paso anterior pero éste no está fijo 

#+end_src

Which is is a bit odd, then the code is  filled.

#+begin_src 
            z = faux(t, yk, f, h, y); % hay que tener en cuenta que durante este bucle sólo se está
                                                                   % considerando el tiempo t=tk +h
                                                                   % con h valor de paso que
                                                                   % corresponda, pero se mantiene
                                                                   % fijo así como también se toma
                                                                   % el valor inicial de y del paso
                                                                   % anterior pero éste no está fijo

#+end_src

Conclusion this seems worse than before. Sorry. I am puzzled


** UB:31.07.2023:17:22: New tests  with commit 3c0c6c52bb6d799afc5ea82b974a91ae8e48dc49
Taking the following line form file =fill_prob2.m=

Namely 

#+begin_src 
        diff = 100;                                              % se toma un numero arbitrariamente grande para inicializar el error de la iteración simple
#+end_src

Running =matlab-fill-comment-line= gives now error, namely


#+begin_src
Debugger entered--Lisp error: (error "Fill algorithm failed!")
  signal(error ("Fill algorithm failed!"))
  error("Fill algorithm failed!")
  matlab-fill-paragraph(nil)
  #f(compiled-function (&optional justify region) "Fill paragraph at or after point.\n\nIf JUSTIFY is non-nil (interactively, with prefix argument), justify as well.\nIf `sentence-end-double-space' is non-nil, then period followed by one\nspace does not end a sentence, so don't break a line there.\nThe variable `fill-column' controls the width for filling.\n\nIf `fill-paragraph-function' is non-nil, we call it (passing our\nargument to it), and if it returns non-nil, we simply return its value.\n\nIf `fill-paragraph-function' is nil, return the `fill-prefix' used for filling.\n\nThe REGION argument is non-nil if called interactively; in that\ncase, if Transient Mark mode is enabled and the mark is active,\ncall `fill-region' to fill each of the paragraphs in the active\nregion, instead of just filling the current paragraph." (interactive #f(compiled-function () #<bytecode -0x6a515d0afcffb72>)) #<bytecode -0x1d9641585f325b63>)(nil)
  apply(#f(compiled-function (&optional justify region) "Fill paragraph at or after point.\n\nIf JUSTIFY is non-nil (interactively, with prefix argument), justify as well.\nIf `sentence-end-double-space' is non-nil, then period followed by one\nspace does not end a sentence, so don't break a line there.\nThe variable `fill-column' controls the width for filling.\n\nIf `fill-paragraph-function' is non-nil, we call it (passing our\nargument to it), and if it returns non-nil, we simply return its value.\n\nIf `fill-paragraph-function' is nil, return the `fill-prefix' used for filling.\n\nThe REGION argument is non-nil if called interactively; in that\ncase, if Transient Mark mode is enabled and the mark is active,\ncall `fill-region' to fill each of the paragraphs in the active\nregion, instead of just filling the current paragraph." (interactive #f(compiled-function () #<bytecode -0x6a515d0afcffb72>)) #<bytecode -0x1d9641585f325b63>) nil)
  filladapt-funcall(fill-paragraph nil)
  filladapt-fill-paragraph(fill-paragraph nil)
  fill-paragraph(nil)
  matlab-fill-comment-line()
  funcall-interactively(matlab-fill-comment-line)
  call-interactively(matlab-fill-comment-line nil nil)
  command-execute(matlab-fill-comment-line)
#+end_src
